/* 
  다익스트라 알고리즘을 택시에 비유해서 한 번 설명을 쉽게 드려볼게요!
  
  우리는 택시 기사입니다! 그런데, 손님을 태웠어요.
  손님은 A 도시에서 F 도시로 가고 싶어 합니다.
  도시들 사이에는 여러 경로가 있고, 각 경로마다 요금이 다릅니다.

  그런데, 손님은 택시에서 하차 후에 요금에 대한 만족도 조사를 진행한다고 하겠습니다!
  따라서, 우리는 손님에게 가장 저렴한 요금 경로로 운전을 하는 것이 지상과제입니다!
  (사실은 요금 바가지는 좋지 않죠...)
*/

/* 
  각 도시간의 예상 운행 요금은 다음과 같아요!
  여기서 언급되지 않은 운행 요금(예를 들어, "A" -> "D")은 
  직접적으로 갈 수가 없는 도시(다시 말해서, "A" 도시에서 "D" 도시로 한 번에 가는 것은 없어요!)라는 것을 뜻해요!
*/
const taxiPrices = [
    ["A", "B", 2000],
    ["A", "C", 4000],
    ["B", "C", 1000],
    ["B", "D", 7000],
    ["C", "E", 3000],
    ["D", "E", 1000],
    ["E", "F", 5000],
  ];
  
  /* 
    좋아요! 이제, 각 도시간의 예상 운행 요금이라는 필수 데이터가 준비가 되어있으니 이걸 그래프로 표현해볼게요!
  */
  const graph = {};
  taxiPrices.forEach(([u, v, w]) => {
    /* 
      없는 키라면 일단 객체로 만들어줘야 된다는 것은 인지상정! 
      즉, 출발 도시(u)나 도착 도시(v)가 그래프에 없다면 빈 객체로 초기화합니다!
    */
    if (!graph[u]) {
      graph[u] = {};
    }
    if (!graph[v]) {
      graph[v] = {};
    }
  
    /* 
      우리는 양방향 도로에요! ["A", "B", 2000]라는 것은 A->B도 2000원이지만 B->A도 2000원이란 얘기입니다! 
    */
    graph[u][v] = w;
    graph[v][u] = w;
  });
  /* 
    수업 시간에 설명드렸다시피 이제 이 그래프 정보를 통해서 다익스트라 알고리즘으로 가장 저렴한 요금이 나오는 경로를 찾아볼게요!
  */
  function findCheapestPrice(graph, start, end) {
    /* 
      준비 단계에요. 필요한 정보를 저장할 객체들을 만듭니다!
    */
    let costs = {};
    let visited = {};
  
    /* 
      이제 초기 상태를 설정해줍니다.
      시작하는 도시(start)에서는 시작하는 도시(start)까지의 요금은 0원이에요.
      즉, A 도시에서 시작하면 A까지의 요금은 0원인 것이죠.
  
      다른 모든 도시까지의 초기 요금은 '무한대'로 설정합니다.
      왜냐하면, 아직 경로를 모르니까요.
      시작 시점에서는 다른 도시들로 직접 갈 수 있는지, 갈 수 있다면 그 요금이 얼마인지 아직 확인하지 않은 상태에요!
      그래서, 이 '무한대' 값에 대해서 오해를 하시면 안되는 것이 "이 도시로 갈 수 없다"가 아니라 "아직 어떻게 가야 할지 모른다"는 뜻입니다!
  
      우리는 운전을 시작하면서 다른 도시들로 가는 경로와 요금을 하나씩 알아가기 시작하는 것입니다.
      새로운 정보를 얻을 때마다 각 도시로 가는 최선의 경로와 요금을 계속 업데이트를 해야하고요!
    */
    for (let city in graph) {
      /* 
        바로 위의 주석에서처럼 시작하는 도시면 0원이고 나머진 '무한대'로 요금 초기화!
      */
      costs[city] = city === start ? 0 : Infinity;
      /* 
        모든 도시들은 아직 방문 전이니 false로 초기화를 해줘요!
      */
      visited[city] = false;
    }
  
    // 3. 모든 도시를 방문할 때까지 반복
    while (true) {
      let currentCity = null;
      let lowestCost = Infinity;
  
      /* 
        최초에는 시작 도시가 currentCity가 되겠죠?
        다만, 이후 코드(visited[currentCity] = true;)에서 시작 도시는 방문 처리가 될 거에요!
        그러면, 가장 저렴한 요금으로 갈 수 있는 다음 도시가 currentCity가 될 것이고 이 흐름이 계속 반복이 됩니다!
      */
      for (let city in costs) {
        /* 
          방문을 하지 않은 도시 중에서 가장 저렴하게 갈 수 있는 곳으로 가야합니다! 그래야 싸니까요!
        */
        if (!visited[city] && costs[city] < lowestCost) {
          currentCity = city;
          lowestCost = costs[city];
        }
      }
  
      /* 
        모든 도시를 방문했거나(visited[city]가 전부 true면 currentCity는 null) 목적지에 도착했다면 더 이상 경로를 더 탐색하지 않아도 됩니다!
      */
      if (currentCity === null || currentCity === end) {
        break;
      }
  
      /*
        현재 도시 방문 처리 완료!
      */
      visited[currentCity] = true;
  
      /* 
        이제 가장 중요한 순간이에요.
        여기서는, 현재 위치에서 갈 수 있는 도시들 확인을 하고 새 요금 계산 및 요금 업데이트를 해주는 것이에요!
        문제에 나온대로 A 도시 -> F 도시로 가는 것을 예시로 설명해드릴게요!
        
        일단, A 도시에서 시작한다라고 치면 A 도시에서 갈 수 있는 도시는 B(2000원), C(4000원)이겠죠? 이 정보를 메모해둡니다.
        그러면, 이 시점에서 알고 있는 가장 저렴한 경로는 A -> B (2000원)이므로 B로 이동합니다!
  
        B로 이동을 했어요. 이제, B 도시에서 갈 수 있는 도시는 C, D가 있습니다.
        이 때! 기존 A -> C는 4000원이었는데 A -> B는 2000원이고 B -> C는 1000원이죠? 
        기존에 알고 있던 요금보다 새롭게 계산된 요금이 더 저렴하네요?! 그러면 이제 이 요금을 업데이트 해줍니다!
        (3000원으로 갈 수 있는 곳을 4000원이라고 얘기할 이유가 전혀 없으니까요!)
        그렇다면, A -> D는 A -> B는 2000원 + B -> D는 7000원이라 총 9000원입니다.
        당연히, C로 이동을 해야겠죠?
  
        이제 C로 이동을 했습니다. 이제, C 도시에서 갈 수 있는 도시는 E밖에 없어요.
        그러면, A -> E는 A -> C는 3000원이고 C -> E는 3000원이니 총 6000원입니다!
  
        이제, E로 이동을 했고 끝이 다 와갑니다. E 도시에서 갈 수 있는 도시는 F밖에 없어요.
        그러면, A -> E는 6000원이고 E -> F는 5000원이니 A -> F로 가는 가장 저렴한 요금은 총 11000원입니다! 
      */
      for (let neighborCity in graph[currentCity]) {
        if (!visited[neighborCity]) {
          /* 
            방문하지 않은 도시에 대해서만 체크할 거에요! 새로운 요금은 아래의 1과 2를 더한 요금이에요.
              1. 현재 도시까지 오면서 지불한 요금(costs[currentCity]). 이 요금은 가장 저렴하게 온 요금입니다.
              2. 이웃 도시로 가는데 필요한 요금
          */
          let newCost = costs[currentCity] + graph[currentCity][neighborCity];
  
          /*
            만약, 새로운 요금이 기존에 알고 있었던 이웃에 가는 요금보다 저렴하다면 업데이트를 해줍니다!
          */
          if (newCost < costs[neighborCity]) {
            costs[neighborCity] = newCost;
          }
        }
      }
    }
  
    /* 
      end 도시까지 가는 최소 요금을 반환해주면 끝!
    */
    return costs[end];
  }
  
  let start = "A";
  let end = "F";
  let cheapestCost = findCheapestPrice(graph, start, end);
  console.log(
    `도시 ${start}에서 도시 ${end}까지 가는 최소 택시 요금은 ${cheapestCost}입니다.`
  );